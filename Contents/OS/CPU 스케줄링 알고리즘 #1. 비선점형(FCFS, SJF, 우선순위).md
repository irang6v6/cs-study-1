# CPU 스케줄링

강의 번호: OS
작성일시: 2023년 1월 16일 오전 8:44

### 01. 스케줄링의 개요

CPU 스케줄링은 어떤 작업에 CPU를 먼저 배정할 지 결정하는 것

### 02. 스케줄링 시 고려사항

1. **선점형 스케줄링과 비선점형 스케줄링**
    1. 선점형 스케줄링
        1. 어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 CPU를 강제로               빼앗을 수 있는 스케줄링 방식
        2. 하나의 프로세스가 CPU를 독점할 수 없기 때문에 빠른 응답시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합
        3. 문맥교환과 같은 부가적인 작업으로 인해 낭비가 생기는 것이 단점 
        
    2. 비선점형 스케줄링
        1. 어떤 프로세스가 CPU를 점유하면 다른 CPU가 이를 빼앗을 수 없는 스케줄링 방식
        2. 선점형 스케줄링보다 스케줄러의 작업이 적고 문맥 교환에 의한 낭비도 적다. 
        3. CPU사용시간이 긴 프로세스 때문에 CPU 사용시간이 짧은 여러 프로세스가 오랜시간 기다리게 되어 전체 시스템의 처리율이 떨어진다. 
    
    
2. **프로세스의 우선순위**
    
    
    1. 커널 프로세스 >>> 일반 프로세스
        
        
    2. 전면 프로세스 >>> 후면 프로세스
        1. 말그대로 맨 앞에 띄워져서 현재 작업하고 있는 창인지, 뒤쪽에 띄워져만 있는 창인지에 따라 우선순위가 갈린다는 말
    3. 대화형 프로세스 >>> 일괄처리 프로세스
        1. ***일괄 처리*** 시스템이 작업 처리량을 중요시하는 반면 ***대화형***
         시스템에서는 응답 시간을 중요시
    4. 입출력 집중 프로세스 >>> CPU 집중 프로세스
        1. 입출력 집중 프로세스는 CPU 사용은 짧고 입출력 대기가 길기 때문에 이 녀석이 대기할때 다른 프로세스가 CPU를 사용할 수 있다. 그래서 얘의 CPU스케줄링을 빨리빨리 처리하는 것이 더 이득

참고) 준비큐


### 03. 스케줄링 알고리즘

## 비선점형

남이 못 뺏어감

### 1. FCFS

가장 먼저 온 것을 가장 먼저 처리하는 알고리즘

프로세스 수행시간은 고려하지 않음


단점 1. 늦게 오면 준비 큐에서 오래 기다려야 하지만 순서가 오면 처리되는 것은 보장됨 (convoy effect)

단점 2. 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어진다. 

### 2. SJF(Shortest Job First)

준비 큐에 있는 프로세스 중에 실행시간이 가장 짧은 프로세스부터 CPU에 할당 → 그걸 미리 어떻게 알지? → 과거 수행했던 시간을 기준으로 판단 

FCFS의 콘보이효과를 완화하여 시스템의 효율을 높이지만, 

단점 1. 수행시간이 가장 짧은 프로세스가 계속 우선순위를 가져가기 때문에 긴 시간을 가진 프로세스가 실행되지 않는 아사 현상(starvation)이 일어난다. 

→ **aging으로 완화할 수 있음**

프로세스가 양보할 수 있는 우선순위의 상한선을 정하는 방식. 근데 에이징 값을 어떻게 정해야 할지도 문제라서 한계가 있음

단점 2. 종료시간 파악 어려움 

결론 : 안씀 

## 선점형

인터셉트 가능 

### 1. 라운드 로빈

한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식 


할당 시간(타임슬라이스)이 너무 길면 FCFS가 되고 너무 짧으면 문맥교환 시간이 오래걸려 오히려 비효율적임


유닉스 운영체제에서는 타임슬라이스가 대략 100밀리초라고 한다.. 

### 2. SRT (Shortest Remaining Time)

라운드로빈+SJF

남은 시간이 가장 적은 프로세스에 CPU를 할당 

단점 1. 현재 진행중인 프로세스와 큐에 남아있는 프로세스의 남은 시간을 주기적으로 계산해야 하고, 남은 시간이 더 적은 프로세스와 문맥교환을 해야 하므로 SJF에는 없는 작업이 추가된다.

단점 2. 운영체제가 프로세스의 종료 시간을 예측하기 어렵다. 아.사.현.상.

### 3. 우선순위

프로세스마다 우선순위를 정해서 스케줄링에 반영한다

딱봐도 아.사.

### 다단계 큐 스케줄링

우선순위에 따라 준비 큐를 여러 개 사용하는 방식 

프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입

라운드 로빈 방식(각 단계의 큐에서만 라운드로빈)으로 운영되는 큐는 우선순위에 따라 다단계로 나뉘어 있어 큐에 삽입되는 것만으로도 우선순위가 결정된다. 

우선순위는 고정형 우선순위를 사용하며, 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다. 


프로세스의 우선순위와 작업 형태를 고려해서 스케줄링 할 수 있다!

그런데 또 우선순위가 높은 녀석들 때문에 우선순위가 낮은 프로세스들이 무기한 연기를 해야하지 않을까?

→ **다단계 피드백 큐 스케줄링** 

### 다단계 피드백 큐 스케줄링

- 우선순위가 낮은 프로세스에 불리한 ‘다단계 큐 스케줄링’의 문제점 보완
- 기본적인 형태는 같음
- 차이
    - 다단계 큐 스케줄링 : 우선순위가 고정형
    - 다단계 피드백 큐 스케줄링 : CPU를 사용하고 난 뒤 프로세스의 우선순위가 낮아짐. 프로세스가 원래의 큐로 돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다, 큐마다 타임 슬라이스가 다르다
        
        → 우선순위가 낮은 프로세스의 작업이 연기되는 것을 완화
        


**다단계 피드백 큐 스케줄링이 오늘날 운영체제가 CPU 스케줄링을 위해 일반적으로 사용하는 방식으로, 변동 우선순위 알고리즘의 전형적인 예시다.**